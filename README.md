# [Coding Test _ DAEA TI  주식] 거래 적기 선택하기(max_Profit 구현)
한 번의 매수와 매도를 통해서 최대 수익을 낼 수 있는 거래 적기를 선택한다.  
단, 사고 팔지 않았을 경우를 고려해야하며 이익은 0으로 판단한다.  
또한 거래의 적기 시기를 판단할 수 있도록 구현한다.  


## 코드 설명
***input: prices array***  
***output: max(prices[j]-prices[i])***
***j,i의 시점***

매수를 한 시점 i  
매도를 한 시점 j  
-> 시계열 성 데이터이므로 i<j를 만족해야함  
prices[j]-prices[i] 가 최대가 되도록 알고리즘을 구현  

모든 경우의 수의 비교한 방법도 존재하지만, 이는 효율성이 떨어지므로 다른 방법을 고안
* 최대 수익을 도출하기 위해서는 싼 값에 주식을 매수하는 것이 중요
* 리스트의 순서대로 최소가 되는 매수액을 업데이트하며 그 이후의 값을 활용하여 이익/손해를 계산하고, 더 큰 수익을 얻었을 때의 값과 시기를 저장한다.
  
***알고리즘***  
배열의 첫번 째 값인 prices[0]을 min_prices로 설정한 뒤, 시간이 지날수록 더 작은 값이 있을 경우 값을 업데이트 한다.  
업데이트 된 최소값을 각 자리의 수에서 빼주며 이익/손해를 계산하고 임시 변수인 temp에 값을 저장하여 기존의 최댓값과 비교하여 max_profit을 업데이트한다.  
최대 수익이 발생한 시기를 알아보기 위해 값이 업데이트 될 시의 시기를 저장한다. 

***Default Value***  
```c
maxProfit = 0    #수익이 발생하지 않은 경우, 0을 출력
min_price = prices[0]    #첫 번째 값을 기본 값으로 하여 시작하고, 더 작은 값은 값이 있을 경우 값을 업데이트
update_time_min_temp = 1    #첫 번째 값이 최소 값으로 값이 업데이트가 발생하지 않을 경우를 고려    
```  

***적기 파악하기***
* ***매도 시점 -***  maxProfit이 최종적으로 업데이트 된 경우, 매도 시점을 의미한다. 
* ***매수 시점 -***  min_Price에서 매수한다고 해서 무조건 최대 이익이 발생하는 것은 아님. 그러므로 임시 변수(update_time_min_temp)를 활용하여 min값을 저장하고, 최대 이익이 발생한 경우의 매수 시점은 별도로 저장(update_time_min)하고 이를 매수 시점이라고 판단
  
***수익 없는 경우***
1) arr의 길이가 1인 경우
   length의 범위가 1~10^5이므로 1인 경우, 매도와 매수가 불가능하므로 수익 계산을 할 수 없으므로 예외 처리(return 0)
2) 수익이 없거나 오히려 손해일 경우
   기본값을 0으로 설정하여 0보다 큰 경우만 값을 업데이트 한 뒤, 더 큰 값이 들어올 경우 값을 업데이트하여 최종적으로 최대 수익 값을 도출한다. 
         

## 최적의 알고리즘 구현하기

***시간 복잡도***
시간 복잡도를 확인하기 위해 for문에 실행 횟수를 알아보기 위해 n을 출력  
n번 반복 시, 최적의 시간인 O(n)임을 알 수 있다.  

* prices[i]의 범위가 ***[0,10^4]*** 이기 때문에 0원에 사고, 10000원에 팔 경우, 최대 수익 발생인 10000이 발생.  

그러므로 max_Profit이 10000이 될 경우, 더 이상 비교할 필요가 없어 for문들 종료하여 시간 복잡도를 절약한다.  


O(n)의 시간복잡도보다 더 절약된 것을 알 수 있다. 
