# [Coding Test _ DAEA TI  주식] 거래 적기 선택하기(max_Profit 구현)
한 번의 매수와 매도를 통해서 최대 수익을 낼 수 있는 거래 적기를 선택한다.  
단, 사고 팔지 않았을 경우를 고려해야하며 이익은 0으로 판단한다.  
또한 거래의 적기 시기를 판단할 수 있도록 구현한다.  


## 코드 설명
***input: prices array***  
***output: max(prices[j]-prices[i])***
***j,i의 시점***

매수를 한 시점 i  
매도를 한 시점 j  
-> 시계열 성 데이터이므로 i<j를 만족해야함  
prices[j]-prices[i] 가 최대가 되도록 알고리즘을 구현  


***최대 이익 구하기***  
모든 경우의 수의 비교한 방법도 존재하지만, 이는 효율성이 떨어지므로 다른 방법을 고안
* 최대 수익을 도출하기 위해서는 싼 값에 주식을 매수하는 것이 중요
* 리스트의 순서대로 최소가 되는 매수액을 업데이트하며 그 이후의 값을 활용하여 이익/손해를 계산하고, 더 큰 수익을 얻었을 때의 값과 시기를 저장한다.
  
***알고리즘***  
배열의 첫번 째 값인 prices[0]을 min_prices로 설정한 뒤, 시간이 지날수록 더 작은 값이 있을 경우 값을 업데이트 한다.  
업데이트 된 최소값을 각 자리의 수에서 빼주며 이익/손해를 계산하고 임시 변수인 temp에 값을 저장하여 기존의 최댓값과 비교하여 max_profit을 업데이트한다.  
최대 수익이 발생한 시기를 알아보기 위해 값이 업데이트 될 시의 시기를 저장한다. 

***Variable***  
```
no = 0   #시기를 저장하기 위한 변수
maxProfit = 0    #최대 이익을 저장. 수익이 발생하지 않은 경우, 0을 출력
min_price = prices[0]    #첫 번째 값을 기본 값으로 하여 시작하고, 더 작은 값이 있을 경우 값을 업데이트
update_time_min_temp = 1    #값이 업데이트가 발생하지 않을 경우를 고려(첫 번째 값이 리스트에서 최소값일 경우)하여 기본 값은 1로 설정
update_time_min = 1    #매수 시기 파악을 위한 변수
```  

***적기 파악하기***  prices[0] -> no: 1
* ***매도 시점 -***  maxProfit이 최종적으로 업데이트 된 경우, 매도 시점을 의미한다. 
* ***매수 시점 -***  min_Price에서 매수한다고 해서 무조건 최대 이익이 발생하는 것은 아님. 그러므로 임시 변수(update_time_min_temp)를 활용하여 min값을 저장하고, 최대 이익이 발생한 경우의 매수 시점은 별도로 저장(update_time_min)하고 이를 매수 시점이라고 판단
  
***수익 없는 경우***
1) arr의 길이가 1인 경우  
   length의 범위가 1~10^5이므로 1인 경우, 매도와 매수가 불가능하므로 수익 계산을 할 수 없으므로 예외 처리(return 0)
2) 수익이 없거나 오히려 손해일 경우  
   기본값을 0으로 설정하여 0보다 큰 경우만 값을 업데이트 한 뒤, 더 큰 값이 들어올 경우 값을 업데이트하여 최종적으로 최대 수익 값을 도출한다. 
         

## 최적의 알고리즘 구현하기

***시간 복잡도/메모리***
* 위에서 언급한 바와 같이 중첩 for문을 사용하여 모든 값을 계산할 경우, 시간 복잡도가 O(n) 이상이 되므로 이를 보완하는 방법을 알아보았고, 한 번의 for문을 사용하여 값을 계산하여 시간 복잡도를 줄였다. 
* 값 비교(min,max) 시, 최소한의 변수를 생성하여 비교하기 위해 임시 변수를 활용하여 메모리 효율 고려

***불필요한 작업 제거***
* prices[i]의 범위가 ***[0,10^4]*** 이기 때문에 0원에 사고, 10000원에 팔 경우, 발생 가능한 최대 수익인 10000 
그러므로 max_Profit이 10000이 될 경우, 더 이상 비교할 필요가 없어 for문들 종료하여 불필요한 작업을 제거한다. 
